;;; -*- Gerbil -*-
;;; (C) vyzo
;;; actor rpc wire data representation
package: std/actor

(import :gerbil/gambit/bits
        :gerbil/gambit/fixnum
        :std/error
        :std/misc/buffer
        :std/text/utf8
        (only-in :std/srfi/1 reverse!))
(export #t)

(begin-foreign
  (c-declare #<<END-C
#define U8_DATA(obj) ___CAST (___U8*, ___BODY_AS (obj, ___tSUBTYPED))

static double ffi_read_float_bytes (___SCMOBJ bytes)
{
 return *(double*)(U8_DATA (bytes));
}

static int ffi_write_float_bytes (double val, ___SCMOBJ bytes)
{
 *(double*)(U8_DATA (bytes)) = val;
  return 0;
}
END-C
)

  (define-macro (define-c-lambda id args ret #!optional (name #f))
    (let ((name (or name (##symbol->string id))))
      `(define ,id
         (c-lambda ,args ,ret ,name))))

  (define-c-lambda std/actor/xdr#xdr-float->bytes!
    (double scheme-object) int
    "ffi_write_float_bytes")

  (define-c-lambda std/actor/xdr#xdr-bytes->float
    (scheme-object) double
    "ffi_read_float_bytes")
)

(extern                                 ; foreign
  xdr-float->bytes! xdr-bytes->float)

(def current-xdr-type-registry
  (make-parameter #f))

(defstruct XDR (pred read write)
  id: std/actor#XDR::t)

(defstruct opaque (type data)
  id: std/actor#opaque::t)

(defstruct (xdr-error io-error) ()
  id: std/actor/xdr-error::t)

(define (raise-xdr-error where what . irritants)
  (raise (make-xdr-error what irritants where)))

(def (xdr-read buffer types)
  (parameterize ((current-xdr-type-registry types))
    (xdr-read-object buffer)))

(def (xdr-write obj buffer types)
  (parameterize ((current-xdr-type-registry types))
    (xdr-write-object obj buffer)))

;; Gerbil eXternal Data Representation
;; non acyclic objects
;; single byte declares type followed by the content
;; all simple objects can be encoded
;; hash-tables are unmarshalled as hash-table
;; opaque objects are typed binaries that could not be marshalled
;;  by with the type registry in effect
;; structure objects must eitherhave an entry in the type registry
;;  mapping their type id to an XDR object, or have an :xdr
;;  method that produces an XDR encodable object
;;  if the structure cannot be marshalled, it is encoded as opaque
;;  with the binary representation generated by object->u8vector
;;  and decoded with u8vector->object
(def xdr-proto-type-void      #x00)
(def xdr-proto-type-false     #x01)
(def xdr-proto-type-true      #x02)
(def xdr-proto-type-null      #x03)
(def xdr-proto-type-pair      #x04)
(def xdr-proto-type-int       #x05)
(def xdr-proto-type-float     #x06)
(def xdr-proto-type-string    #x07)
(def xdr-proto-type-symbol    #x08)
(def xdr-proto-type-keyword   #x09)
(def xdr-proto-type-values    #x0a)
(def xdr-proto-type-vector    #x0b)
(def xdr-proto-type-u8vector  #x0c)
(def xdr-proto-type-hash      #x0d)
(def xdr-proto-type-opaque    #x0e)
(def xdr-proto-type-structure #x0f)

(def xdr-proto-type-hash-eq    #x00)
(def xdr-proto-type-hash-eqv   #x01)
(def xdr-proto-type-hash-equal #x02)

(def *xdr-proto-types*
  (make-vector 16))

(def (xdr-read-object buffer)
  (let (type (buffer-read-u8 buffer))
    (cond
     ((eof-object? type))
     ((and (fixnum? type) (fx>= type 0) (fx< type (vector-length *xdr-proto-types*)))
      (let (xdr (vector-ref *xdr-proto-types* type))
        ((XDR-read xdr) buffer)))
     (else
      (raise-xdr-error 'xdr-read  "unknown object type" type buffer)))))

(def (xdr-write-object obj buffer)
  (let (type (xdr-object-type obj))
    (if type
      (let (xdr (vector-ref *xdr-proto-types* type))
        ((XDR-write xdr) obj buffer))
      (let (xdr (vector-ref *xdr-proto-types* xdr-proto-type-opaque))
        ((XDR-write xdr) (make-opaque #f (object->u8vector obj)) buffer)))))

(def (xdr-object-type obj)
  (cond
   ((void? obj)       xdr-proto-type-void)
   ((not obj)         xdr-proto-type-false)
   ((true? obj)       xdr-proto-type-true)
   ((null? obj)       xdr-proto-type-null)
   ((pair? obj)       xdr-proto-type-pair)
   ((int? obj)        xdr-proto-type-int)
   ((real? obj)       xdr-proto-type-float)
   ((string? obj)     xdr-proto-type-string)
   ((symbol? obj)     xdr-proto-type-symbol)
   ((keyword? obj)    xdr-proto-type-keyword)
   ((##values? obj)   xdr-proto-type-values)
   ((vector? obj)     xdr-proto-type-vector)
   ((u8vector? obj)   xdr-proto-type-u8vector)
   ((hash-table? obj) xdr-proto-type-hash)
   ((opaque? obj)     xdr-proto-type-opaque)
   ((object? obj)     xdr-proto-type-structure)
   (else #f)))

(def (xdr-type-registry-get type-id)
  (cond
   ((current-xdr-type-registry)
    => (cut hash-get <> type-id))
   (else #f)))

(defrules defxdr-proto-types ()
  ((_ rule ...)
   (begin
     (defxdr-proto-type-decl rule) ...)))

(defrules defxdr-proto-type-decl ()
  ((_ (type xdr-t pred xdr-read-e xdr-write-e))
   (begin
     (def xdr-t
       (make-XDR pred xdr-read-e xdr-write-e))
     (vector-set! *xdr-proto-types* type xdr-t))))

;;; xdr readers
(def xdr-void-read  void)
(def xdr-false-read false)
(def xdr-true-read  true)
(def (xdr-null-read . args)
  '())

(def (xdr-pair-read buffer)
  (cons
   (xdr-read-object buffer)
   (xdr-read-object buffer)))

(def (xdr-int-read buffer)
  (let* ((hd (buffer-read-u8 buffer))
         (_  (when (eof-object? hd)
               (raise-xdr-error 'xdr-read "premature end of input" buffer)))
         (sign (not (##fxzero? (##fxand hd #x80))))
         (bytes (##fxand hd #x7f))
         (bytes (if (##fx< bytes 127)
                  bytes
                  (xdr-read-object buffer))))
    (let lp ((k 0) (value 0) (shift 0))
      (cond
       ((##fx< k bytes)
        (let (u8 (buffer-read-u8 buffer))
          (cond
           ((eof-object? u8)
            (raise-xdr-error 'xdr-read "premature end of input" buffer))
           ((##fxarithmetic-shift-left? u8 shift)
            => (lambda (bits)
                 (lp (##fx+ k 1)
                     (##fxior bits value)
                     (##fx+ shift 8))))
           (else
            (lp (##fx+ k 1)
                (bitwise-ior (arithmetic-shift u8 shift)
                             value)
                (##fx+ shift 8))))))
         (sign (- value))
         (else value)))))

(def (xdr-float-read buffer)
  (let* ((bytes (make-u8vector 8))
         (ilen (buffer-read-subu8vector bytes 0 8 buffer)))
    (if (fx= ilen 8)
      (xdr-bytes->float bytes)
      (raise-xdr-error 'xdr-read "premature end of input" buffer))))

(def (xdr-binary-read buffer K)
  (let* ((len (xdr-read-object buffer))
         (buf (make-u8vector len))
         (ilen (buffer-read-subu8vector buf 0 len buffer)))
    (if (fx= len ilen)
      (K buf)
      (raise-xdr-error 'xdr-read "premature end of input" buffer))))

(def (xdr-string-read buffer)
  (xdr-binary-read buffer utf8->string))

(def (xdr-symbol-read buffer)
  (xdr-binary-read
   buffer (lambda (bytes) (string->symbol (utf8->string bytes)))))

(def (xdr-keyword-read buffer)
  (xdr-binary-read
   buffer (lambda (bytes) (string->keyword (utf8->string bytes)))))

(def (xdr-vector-like-read makef start buffer)
  (let* ((len (xdr-read-object buffer))
         (obj (makef len))
         (ilen (fx+ start len)))
    (let lp ((k start))
      (if (fx< k ilen)
        (begin
          (##vector-set! obj k (xdr-read-object buffer))
          (lp (fx1+ k)))
        obj))))

(def (xdr-values-read buffer)
  (xdr-vector-like-read ##make-values 0 buffer))

(def (xdr-vector-read buffer)
  (xdr-vector-like-read ##make-vector 0 buffer))

(def (xdr-u8vector-read buffer)
  (xdr-binary-read buffer values))

(def (xdr-inline-list-read buffer)
  (let lp ((lst []))
    (let (next (xdr-read-object buffer))
      (if (null? next)
        (reverse! lst)
        (lp (cons next lst))))))

(def (xdr-hash-read buffer)
  (let* ((htype (buffer-read-u8 buffer))
         (makef (cond
                 ((eq? htype xdr-proto-type-hash-eq)
                  list->hash-table-eq)
                 ((eq? htype xdr-proto-type-hash-eqv)
                  list->hash-table-eqv)
                 (else
                  list->hash-table)))
         (pairs (xdr-inline-list-read buffer)))
    (makef pairs)))

(def (xdr-opaque-read buffer)
  (let* ((type (xdr-read-object buffer))
         (bytes (xdr-binary-read buffer values)))
    (u8vector->object bytes)))

(def (xdr-structure-read buffer)
  (let (type-id (xdr-read-object buffer))
    (cond
     ((xdr-type-registry-get type-id)
      => (lambda (xdr)
           ((XDR-read xdr) buffer)))
     (else
      (raise-xdr-error 'xdr-read "unknown structure type" type-id buffer)))))

;;; xdr writers
(defrules defxdr-atom-write ()
  ((_ id type)
   (def (id obj buffer)
     (buffer-write-u8 type buffer))))

(defxdr-atom-write xdr-void-write  xdr-proto-type-void)
(defxdr-atom-write xdr-false-write xdr-proto-type-false)
(defxdr-atom-write xdr-true-write  xdr-proto-type-true)
(defxdr-atom-write xdr-null-write  xdr-proto-type-null)

(def (xdr-pair-write obj buffer)
  (buffer-write-u8 xdr-proto-type-pair buffer)
  (xdr-write-object (car obj) buffer)
  (xdr-write-object (cdr obj) buffer))

(def (xdr-int-write obj buffer)
  (buffer-write-u8 xdr-proto-type-int buffer)
  (cond
   ((fixnum? obj)
    (let* ((neg? (##fx< obj 0))
           (sign (if neg?  #x80  0))
           (value (if neg? (##fx- obj) obj))
           (bits (##fxlength value))
           (bytes (##fxarithmetic-shift-right bits 3))
           (rem (##fxand bits #b111))
           (bytes (if (##fxzero? rem) bytes (##fx+ bytes 1)))
           (hd (##fxior sign bytes)))
      (buffer-write-u8 hd buffer)
      (let lp ((k 0) (value value))
        (when (##fx< k bytes)
          (buffer-write-u8 (##fxand value #xff) buffer)
          (lp (##fx+ k 1)
              (##fxarithmetic-shift-right value 8))))))
   (else
    (let* ((sign (if (negative? obj) 1 0))
           (value (abs obj))
           (bits (integer-length value))
           (bytes (fxquotient bits 8))
           (rem   (fxremainder bits 8))
           (bytes (if (fxzero? rem) bytes (fx1+ bytes)))
           ((values hd len)
            (if (fx<  bytes 127)
              (values
                (fxior (fxarithmetic-shift sign 7)
                       bytes)
                #f)
              (values
                (fxior (fxarithmetic-shift sign 7)
                       127)
                #t))))
      (buffer-write-u8 hd buffer)
      (when len
        (xdr-int-write bytes buffer))
      (let lp ((k 0) (value value))
        (when (fx< k bytes)
          (buffer-write-u8 (bitwise-and value #xff) buffer)
          (lp (fx1+ k) (arithmetic-shift value -8))))))))

(def (xdr-float-write obj buffer)
  (let (obj (if (exact? obj)
              (exact->inexact obj)
              obj))
    (buffer-write-u8 xdr-proto-type-float buffer)
    (let (bytes (make-u8vector 8))
      (xdr-float->bytes! obj bytes)
      (buffer-write-subu8vector bytes 0 8 buffer))))

(def (xdr-binary-write bytes buffer)
  (let (len (u8vector-length bytes))
    (xdr-int-write len buffer)
    (buffer-write-subu8vector bytes 0 len buffer)))

(def (xdr-string-write obj buffer)
  (buffer-write-u8 xdr-proto-type-string buffer)
  (xdr-binary-write (string->utf8 obj) buffer))

(def (xdr-symbol-write obj buffer)
  (buffer-write-u8 xdr-proto-type-symbol buffer)
  (xdr-binary-write (string->utf8 (symbol->string obj)) buffer))

(def (xdr-keyword-write obj buffer)
  (buffer-write-u8 xdr-proto-type-keyword buffer)
  (xdr-binary-write (string->utf8 (keyword->string obj)) buffer))

(def (xdr-vector-like-write obj start buffer)
  (let* ((len (##vector-length obj))
         (olen (fx- len start)))
    (xdr-int-write olen buffer)
    (let lp ((k start))
      (when (fx< k len)
        (xdr-write-object (##vector-ref obj k) buffer)
        (lp (fx1+ k))))))

(def (xdr-values-write obj buffer)
  (buffer-write-u8 xdr-proto-type-values buffer)
  (xdr-vector-like-write obj 0 buffer))

(def (xdr-vector-write obj buffer)
  (buffer-write-u8 xdr-proto-type-vector buffer)
  (xdr-vector-like-write obj 0 buffer))

(def (xdr-u8vector-write obj buffer)
  (buffer-write-u8 xdr-proto-type-u8vector buffer)
  (xdr-binary-write obj buffer))

(def (xdr-inline-list-write obj buffer)
  (for-each (cut xdr-pair-write <> buffer) obj)
  (xdr-null-write '() buffer))

(def (xdr-hash-write obj buffer)
  (buffer-write-u8 xdr-proto-type-hash buffer)
  (let (testf (##vector-ref obj 2))     ; _system#.scm
    (cond
     ((or (not testf)
          (eq? testf eq?)
          (eq? testf ##eq?))
      (buffer-write-u8 xdr-proto-type-hash-eq buffer))
     ((or (eq? testf eqv?)
          (eq? testf ##eqv?))
      (buffer-write-u8 xdr-proto-type-hash-eqv buffer))
     (else
      (buffer-write-u8 xdr-proto-type-hash-equal buffer))))
  (xdr-inline-list-write (hash->list obj) buffer))

(def (xdr-opaque-write obj buffer)
  (buffer-write-u8 xdr-proto-type-opaque buffer)
  (xdr-write-object (opaque-type obj) buffer)
  (xdr-binary-write (opaque-data obj) buffer))

(def (xdr-structure-write obj buffer)
  (let (type-id (##type-id (object-type obj)))
    (cond
     ((xdr-type-registry-get type-id)
      => (lambda (xdr)
           (buffer-write-u8 xdr-proto-type-structure buffer)
           (xdr-write-object type-id buffer)
           ((XDR-write xdr) obj buffer)))
     (else
      (xdr-write-object (make-opaque type-id (object->u8vector obj))
                        buffer)))))

(def (int? obj)
  (and (integer? obj)
       (exact? obj)))

;;; XDR type declarations
(defxdr-proto-types
  (xdr-proto-type-void      void-t      void?       xdr-void-read     xdr-void-write)
  (xdr-proto-type-false     false-t     not         xdr-false-read    xdr-false-write)
  (xdr-proto-type-true      true-t      true?       xdr-true-read     xdr-true-write)
  (xdr-proto-type-null      null-t      null?       xdr-null-read     xdr-null-write)
  (xdr-proto-type-pair      pair-t      pair?       xdr-pair-read     xdr-pair-write)
  (xdr-proto-type-int       int-t       int?        xdr-int-read      xdr-int-write)
  (xdr-proto-type-float     float-t     real?       xdr-float-read    xdr-float-write)
  (xdr-proto-type-string    string-t    string?     xdr-string-read   xdr-string-write)
  (xdr-proto-type-symbol    symbol-t    symbol?     xdr-symbol-read   xdr-symbol-write)
  (xdr-proto-type-keyword   keyword-t   keyword?    xdr-keyword-read  xdr-keyword-write)
  (xdr-proto-type-values    values-t    ##values?   xdr-values-read   xdr-values-write)
  (xdr-proto-type-vector    vector-t    vector?     xdr-vector-read   xdr-vector-write)
  (xdr-proto-type-u8vector  u8vector-t  u8vector?   xdr-u8vector-read xdr-u8vector-write)
  (xdr-proto-type-hash      hash-t      hash-table? xdr-hash-read     xdr-hash-write)
  (xdr-proto-type-opaque    opaque-t    opaque?     xdr-opaque-read   xdr-opaque-write)
  (xdr-proto-type-structure structure-t object?     xdr-structure-read xdr-structure-write))

(def any-t
  (make-XDR true xdr-read-object xdr-write-object))

(def (U . xdrs)
  (let* ((preds   (map XDR-pred xdrs))
         (readers (map XDR-read xdrs))
         (writers (map XDR-write xdrs))
         (len     (length preds))
         (indices (iota len))
         (reader-vector (make-vector len)))

    (def (read-e buffer)
      (let (index (buffer-read-u8 buffer))
        (when (eof-object? index)
          (raise-xdr-error 'xdr-read "premature end of input" buffer))
        (let (xdr-read-e (vector-ref reader-vector index))
          (xdr-read-e buffer))))

    (def (write-e obj buffer)
      (let lp ((pred-rest preds) (writer-rest writers) (index 0))
        (match pred-rest
          ([pred . pred-rest]
           (match writer-rest
             ([write-e . writer-rest]
              (if (pred obj)
                (begin
                  (buffer-write-u8 index buffer)
                  (write-e obj buffer))
                (lp pred-rest writer-rest (fx1+ index))))))
          (else
           (raise-xdr-error 'xdr-write "unknown object type" obj)))))

    (def (pred-e obj)
      (ormap preds obj))

    (when (> len 255)
      (error "Cannot create discriminated union; too many types"))
    (for-each (cut vector-set! reader-vector <> <>)
              indices readers)

    (make-XDR pred-e read-e write-e)))
