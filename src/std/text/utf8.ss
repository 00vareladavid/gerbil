;;; -*- Gerbil -*-
;;; (C) vyzo at hackzen.org
;;; string<->utf8 conversion without intermediate ports
package: std/text

(import :gerbil/gambit/bits
        :std/error)
(export string->utf8 utf8->string
        utf8-encode utf8-decode)

(declare (not safe))

(def (string->utf8 str)
  (if (string? str)
    (utf8-encode str)
    (error "Bad argument; expcted string" str)))

(def (utf8->string u8v)
  (if (u8vector? u8v)
    (utf8-decode u8v)
    (error "Bad argument; expected u8vector" u8v)))

(def (utf8-encode str)
  (let* ((u8vlen (utf8-encode-length str))
         (u8v (make-u8vector u8vlen)))
    (utf8-encode! str u8v)
    u8v))

(def (utf8-encode-length str)
  (let (slen (##string-length str))
    (let lp ((i 0) (r 0))
      (if (##fx< i slen)
        (let* ((char (##string-ref str i))
               (clen (utf8-char-length char)))
          (lp (##fx+ i 1)
              (##fx+ r clen)))
        r))))

(def (utf8-char-length char)
  (let (c (##char->integer char))
    (if (fixnum? c)
      (cond
       ((##fx<= c #x7f)      1)
       ((##fx<= c #x7ff)     2)
       ((##fx<= c #xffff)    3)
       ((##fx<= c #x1fffff)  4)
       ((##fx<= c #x3ffffff) 5)
       (else 6))
      6)))

(def (utf8-encode! str u8v)
  (def (encode1 c j bytes)
    (let (u8 (##fx+ (##fx- #xff (##fxarithmetic-shift-right #xff bytes))
                    c))
      (##u8vector-set! u8v j u8)))

  (defrules encode+ ()
    ((_ c j bytes K)
     (let (u8 (##fx+ #x80 (##fxand c #x3f)))
       (##u8vector-set! u8v j u8)
       (K (##fxarithmetic-shift-right c 6)
          (##fx+ j 1)
          bytes))))

  (def (encode2 c j bytes)
    (encode+ c j bytes encode1))
  (def (encode3 c j bytes)
    (encode+ c j bytes encode2))
  (def (encode4 c j bytes)
    (encode+ c j bytes encode3))
  (def (encode5 c j bytes)
    (encode+ c j bytes encode4))
  (def (encode6 c j bytes)
    (let (u8 (##fx+ #x80 (bitwise-and c #x3f)))
      (##u8vector-set! u8v j u8)
      (encode5 (arithmetic-shift c -6)
               (##fx+ j 1)
               bytes)))

  (let (slen (##string-length str))
    (let lp ((i 0) (j 0))
      (when (##fx< i slen)
        (let* ((char (##string-ref str i))
               (c (##char->integer char)))
          (if (fixnum? c)
            (cond
             ((##fx<= c #x7f)
              (##u8vector-set! u8v j c)
              (lp (##fx+ i 1)
                  (##fx+ j 1)))
             ((##fx<= c #x7ff)
              (encode2 c j 2)
              (lp (##fx+ i 1)
                  (##fx+ j 2)))
             ((##fx<= c #xffff)
              (encode3 c j 3)
              (lp (##fx+ i 1)
                  (##fx+ j 3)))
             ((##fx<= c #x1fffff)
              (encode4 c j 4)
              (lp (##fx+ i 1)
                  (##fx+ j 4)))
             ((##fx<= c #x3ffffff)
              (encode5 c j 5)
              (lp (##fx+ i 1)
                  (##fx+ j 5)))
             (else
              (encode6 c j 6)
              (lp (##fx+ i 1)
                  (##fx+ j 6))))
            (begin
              (encode6 c j 6)
              (lp (##fx+ i 1)
                  (##fx+ j 6)))))))))

(def (utf8-decode u8v)
  (let* ((u8vlen (##u8vector-length u8v))
         (str (make-string u8vlen))
         (slen (utf8-decode! u8v str)))
    (##string-shrink! str slen)
    str))

(def (utf8-decode! u8v str)
  (let (u8vlen (##u8vector-length u8v))

    (def (fshi i mask)
      (##fxand (##u8vector-ref u8v i) mask))

    (def (fshl i mask bits)
      (##fxarithmetic-shift-left (fshi i mask) bits))

    (def (decode+ i n)
      (let (i+n (##fx+ i n))
        (if (##fx<= i+n u8vlen)
          (let lp ((i (##fx+ i 1)) (r 0))
            (if (##fx< i i+n)
              (lp (##fx+ i 1)
                  (##fxior (##fxarithmetic-shift-left r 6)
                           (##fxand (##u8vector-ref u8v i) #x3f)))
              r))
          (raise-io-error 'utf8-decode! "incomplete character" u8v i))))

    (def (decode2 i)
      (##fxior (fshl i #b11111 6)
               (decode+ i 2)))

    (def (decode3 i)
      (##fxior (fshl i #b1111 12)
                (decode+ i 3)))
    (def (decode4 i)
      (##fxior (fshl i #b111 18)
               (decode+ i 4)))

    (def (decode5 i)
      (##fxior (fshl i #b11 24)
               (decode+ i 5)))

    (def (decode6 i)
      (let (i+1 (##fx+ i 1))
        (if (##fx< i+1 u8vlen)
          (bitwise-ior (arithmetic-shift (fshi i #b1) 30)
                       (arithmetic-shift (fshi i+1 #x3f) 24)
                       (decode+ i+1 5))
          (raise-io-error 'utf8-decode! "incomplete character" u8v i))))

    (let lp ((i 0) (j 0))
      (cond
       ((##fx< i u8vlen)
        (let (byte (##u8vector-ref u8v i))
          (cond
           ((##fx<= byte #x7f)
            (##string-set! str j (##integer->char byte))
            (lp (##fx+ i 1)
                (##fx+ j 1)))
           ((or (##fx<= byte #xbf)
                (##fx> byte #xfd))
            (raise-io-error 'utf8-decode! "illegal character" u8v byte))
           ((##fx<= byte #xdf)
            (##string-set! str j (##integer->char (decode2 i)))
            (lp (##fx+ i 2)
                (##fx+ j 1)))
           ((##fx<= byte #xef)
            (##string-set! str j (##integer->char (decode3 i)))
            (lp (##fx+ i 3)
                (##fx+ j 1)))
           ((##fx<= byte #xf7)
            (##string-set! str j (##integer->char (decode4 i)))
            (lp (##fx+ i 4)
                (##fx+ j 1)))
           ((##fx<= byte #xfb)
            (##string-set! str j (##integer->char (decode5 i)))
            (lp (##fx+ i 5)
                (##fx+ j 1)))
           (else
            (##string-set! str j (##integer->char (decode6 i)))
            (lp (##fx+ i 6)
                (##fx+ j 1))))))
       (else j)))))
